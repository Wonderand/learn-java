package DataStructuresAndAlgorithms.链表;/** * @Classname DoubleLinkedListDemo * @Pakage: DataStructuresAndAlgorithms.链表 * @Author: hzr * @Description TODO * @Date 2024/10/5 8:52 * @Created by 22906 * @Version 1.0.0 */public class DoubleLinkedListDemo {    public static void main(String[] args) {        // 测试        // 先创建节点        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");        HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");        HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");        // 创建一个双向链表对象        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();//        doubleLinkedList.add(hero1);//        doubleLinkedList.add(hero2);//        doubleLinkedList.add(hero3);//        doubleLinkedList.add(hero4);        doubleLinkedList.addByOrder(hero4);        doubleLinkedList.addByOrder(hero1);        doubleLinkedList.addByOrder(hero3);        doubleLinkedList.addByOrder(hero2);        doubleLinkedList.list();        // 修改        HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙");        doubleLinkedList.update(newHeroNode);        System.out.println("修改后的链表情况");        doubleLinkedList.list();        // 删除        doubleLinkedList.delete(3);        System.out.println("删除后的链表情况");        doubleLinkedList.list();    }}// 创建一个双向链表的类class DoubleLinkedList{    // 先初始化一个头节点，头节点不要动，不存放具体数据    private HeroNode2 head = new HeroNode2(0,"","");    //返回头节点    public HeroNode2 getHead(){        return head;    }    // 遍历双向链表的方法    /**     * 显示链表[遍历]     */    public void list(){        // 判断链表是否为空        if (head.next == null){            System.out.println("链表为空");            return;        }        // 因为头节点不能动，因此我们需要一个辅助变量来遍历        HeroNode2 temp = head.next;        while (true){            // 判断是否到最后            if (temp == null){                break;            }            // 输出节点的信息            System.out.println(temp);            // 将next后移            temp = temp.next;        }    }    // 添加一个节点到双向链表的最后    public void add(HeroNode2 heroNode){        // 因为这个hand节点不能动，因此我们需要要一个辅助遍历temp        HeroNode2 temp = head;        // 遍历链表，找到最后        while (true){            // 找到链表最后            if (temp.next == null){                break;            }            // 如果没有找到最后，就将temp后移            temp = temp.next;        }        // 当退出while循环时，temp就指向了链表的最后        // 将最后这个节点的next节点指向新的节点        temp.next = heroNode;        heroNode.pre = temp;    }    public void addByOrder(HeroNode2 heroNode){        // 因为头节点不能动，因此，我们任然需要通过一个辅助指针（变量）来帮助找到添加的位置        // 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了        HeroNode2 temp = head;        boolean flag = false;// flag标志添加的节点是否存在，默认为false        while (true){            if (temp.next == null){//说明temp已经到了链表的最后                break;            }            if (temp.next.no > heroNode.no){// 位置找到，就在temp的后面插入                break;            }else if (temp.next.no == heroNode.no){// 说明要添加的HeroNode的编号已然存在                flag = true;                break;            }            temp = temp.next; // 后移，遍历当前链表        }        if (flag){ // 不能添加，说明编号存在            System.out.printf("准备插入的英雄的编号%d已经存在，不能添加\n",heroNode.no);        } else {            // 插入到链表中，temp的后面            heroNode.next = temp.next;            heroNode.pre = temp;            temp.next = heroNode;            if (heroNode.next != null){                heroNode.next.pre = heroNode;            }        }    }    // 修改一个节点的内容,可以看到双向链表的节点内容修改和单向链表一样    // 只是节点类型改成了HeroNode2    public void update(HeroNode2 newHeroNode){        if (head.next == null){            System.out.println("链表为空");            return;        }        // 找到需要修改的节点，根据no编号        // 定义一个辅助变量        HeroNode2 temp = head.next;        boolean flag = false; //表示是否找到该节点        while (true){            if (temp == null){                break;// 到链表的最后            }            if (temp.no == newHeroNode.no){                flag = true;                break;            }            temp = temp.next;        }        // 根据flag判断是否找到要修改的节点        if (flag){            temp.name = newHeroNode.name;            temp.nickName = newHeroNode.nickName;        }else {// 没有找到            System.out.printf("没有找到编号为%d的节点，不能修改\n",newHeroNode.no);        }    }    // 从双向链表中删除一个节点    // 1.对于双向链表，我们直接可以直接找到要删除的这个节点    // 2.找到后自我删除即可    public void delete(int no){        // 判断当前链表是否为空        if (head.next == null){            System.out.println("链表为空，无法删除");            return;        }        HeroNode2 temp = head.next; //辅助变量（指针）        boolean flag = false; //标识是否找到待删除节点的前一个节点        while (true){            if (temp == null){// 已经到链表的最后节点的next                break;            }            if (temp.no == no){                // 找到了待删除节点的前一个节点temp                flag = true;                break;            }            temp = temp.next; // temp后移，遍历        }        if (flag){//找到            //可以删除            // 单向链表 temp.next = temp.next.next            temp.pre.next = temp.next;            // 这里代码有问题？            // 如果是最后一个节点，就不需要执行下面这句代码，否则就会出现空指针异常            // temp.next = null            if (temp.next != null){                temp.next.pre = temp.pre;            }        } else{            System.out.printf("要删除的%d 节点不存在\n",no);        }    }}// 定义一个HeroNode,每个HeroNode都是一个节点class HeroNode2{    public int no;    public String name;    public String nickName;    public HeroNode2 next; // 指向下一个节点,默认为null    public HeroNode2 pre; // 指向前一个节点,默认为null    // 构造器    public HeroNode2(int no, String name, String nickName) {        this.no = no;        this.name = name;        this.nickName = nickName;    }    // 为了显示方法，重写toString//    @Override//    public String toString() {//        return "HeroNode{" +//                "no=" + no +//                ", name='" + name + '\'' +//                ", nickName='" + nickName + '\'' +//                '}';//    }    @Override    public String toString() {        return "HeroNode2{" +                "no=" + no +                ", name='" + name + '\'' +                ", nickName='" + nickName + '\'' +//                ", next=" + next +                ", pre=" + pre +                '}';    }}